# Analyse Ã©volutions IRVE

```elixir
Mix.install([
  {:ecto_sql, "~> 3.12"},
  {:postgrex, ">= 0.0.0"},
  {:kino_db, "~> 0.2.3"},
  {:jason, "~> 1.4"},
  {:req, "~> 0.5.0"},
  {:nimble_csv, "~> 1.2"},
  {:kino_vega_lite, "~> 0.1.10"}
])
```

## Section

<!-- livebook:{"attrs":"eyJkYXRhYmFzZSI6InRyYW5zcG9ydF9yZXBvIiwiaG9zdG5hbWUiOiJsb2NhbGhvc3QiLCJwYXNzd29yZF9zZWNyZXQiOiIiLCJwb3J0Ijo1NDMyLCJ0eXBlIjoicG9zdGdyZXMiLCJ1c2VfaXB2NiI6ZmFsc2UsInVzZV9zc2wiOmZhbHNlLCJ1c2VybmFtZSI6InBvc3RncmVzIiwidmFyaWFibGUiOiJjb25uIn0","chunks":null,"kind":"Elixir.KinoDB.ConnectionCell","livebook_object":"smart_cell"} -->

```elixir
opts = [
  hostname: "localhost",
  port: 5432,
  username: "postgres",
  password: "",
  database: "transport_repo"
]

{:ok, conn} = Kino.start_child({Postgrex, opts})
```

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwiZGF0YV9mcmFtZV9hbGlhcyI6IkVsaXhpci5FeHBsb3Jlci5EYXRhRnJhbWUiLCJxdWVyeSI6InNlbGVjdCBpZCwgcGF5bG9hZCAtPj4gJ3Blcm1hbmVudF91cmwnIGFzIHVybCwgaW5zZXJ0ZWRfYXQgXG5mcm9tIHJlc291cmNlX2hpc3RvcnkgcmhcbndoZXJlIHJoLnJlc291cmNlX2lkID0gODE2MjNcbm9yZGVyIGJ5IGluc2VydGVkX2F0IGFzYyIsInJlc3VsdF92YXJpYWJsZSI6InJlc3VsdCIsInRpbWVvdXQiOm51bGx9","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
result =
  Postgrex.query!(
    conn,
    ~S"""
    select id, payload ->> 'permanent_url' as url, inserted_at 
    from resource_history rh
    where rh.resource_id = 81623
    order by inserted_at asc
    """,
    []
  )
```

```elixir
columns = ["id", "url", "inserted_at"]
%{columns: columns, rows: rows} = result

snapshots =
  rows
  |> Enum.map(fn x ->
    columns
    |> Enum.zip(x)
    |> Map.new()
  end)
```

```elixir
path = Path.join(__ENV__.file, "../../apps/shared/lib/req_custom_cache.ex") |> Path.expand()
Code.require_file(path)

defmodule Query do
  def cache_dir, do: Path.join(__ENV__.file, "../cache-dir") |> Path.expand()

  def cached_get!(url) do
    req = Req.new() |> Transport.Shared.ReqCustomCache.attach()
    Req.get!(req, url: url, receive_timeout: 100_000, custom_cache_dir: cache_dir())
  end
end

:ok
```

```elixir
task = fn row = %{"url" => url} ->
  IO.puts("getting #{url}")
  try do
  %{status: 200, body: body} = Query.cached_get!(url)
  # NOTE: headers appear as one line at this stage
  Map.put(row, "row_count", (body |> length()) - 1)
  rescue
    _ -> 
      Map.put(row, "error", true)
  end
end

data =
  snapshots
  |> Task.async_stream(
    task,
    max_concurrency: 5,
    on_timeout: :kill_task,
    timeout: 100_000
  )
  |> Stream.map(fn {:ok, result} -> result end)
  |> Stream.reject(fn row -> row["error"] end)
  |> Stream.map(fn x -> Map.take(x, ["inserted_at", "row_count"]) end)
  |> Enum.into([])
```

```elixir
data
|> Kino.DataTable.new()
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6bnVsbCwiaGVpZ2h0IjpudWxsLCJsYXllcnMiOlt7ImFjdGl2ZSI6dHJ1ZSwiY2hhcnRfdHlwZSI6ImJhciIsImNvbG9yX2ZpZWxkIjoicm93X2NvdW50IiwiY29sb3JfZmllbGRfYWdncmVnYXRlIjpudWxsLCJjb2xvcl9maWVsZF9iaW4iOm51bGwsImNvbG9yX2ZpZWxkX3NjYWxlX3NjaGVtZSI6bnVsbCwiY29sb3JfZmllbGRfdHlwZSI6InF1YW50aXRhdGl2ZSIsImRhdGFfdmFyaWFibGUiOiJkYXRhIiwiZ2VvZGF0YV9jb2xvciI6ImJsdWUiLCJsYXRpdHVkZV9maWVsZCI6bnVsbCwibG9uZ2l0dWRlX2ZpZWxkIjpudWxsLCJ4X2ZpZWxkIjoiaW5zZXJ0ZWRfYXQiLCJ4X2ZpZWxkX2FnZ3JlZ2F0ZSI6bnVsbCwieF9maWVsZF9iaW4iOm51bGwsInhfZmllbGRfc2NhbGVfdHlwZSI6bnVsbCwieF9maWVsZF90eXBlIjoidGVtcG9yYWwiLCJ5X2ZpZWxkIjoicm93X2NvdW50IiwieV9maWVsZF9hZ2dyZWdhdGUiOm51bGwsInlfZmllbGRfYmluIjpudWxsLCJ5X2ZpZWxkX3NjYWxlX3R5cGUiOm51bGwsInlfZmllbGRfdHlwZSI6InF1YW50aXRhdGl2ZSJ9XSwidmxfYWxpYXMiOiJFbGl4aXIuVmVnYUxpdGUiLCJ3aWR0aCI6ODAwfQ","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 800)
|> VegaLite.data_from_values(data, only: ["inserted_at", "row_count"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "inserted_at", type: :temporal)
|> VegaLite.encode_field(:y, "row_count", type: :quantitative)
|> VegaLite.encode_field(:color, "row_count", type: :quantitative)
```

```elixir
month_trunc = fn(d) ->
  Date.new!(d.year, d.month, 1)  
end

data
|> Enum.group_by(
  fn(x) -> x["inserted_at"] |> month_trunc.() end,
  fn(x) -> x["row_count"] end
)
|> Enum.map(
  fn({a,b}) -> 
    %{date: a, pdc_count: (Enum.sum(b) / length(b)) |> trunc()}
    end)
|> Kino.DataTable.new()

```
