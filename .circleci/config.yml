version: 2.1

# useful information at https://circleci.com/docs/2.0/language-elixir/
# and https://circleci.com/docs/2.0/reusing-config/#using-the-parameters-declaration

default_docker: &default_docker
  image: << parameters.base_image >>
  environment:
    MIX_ENV: test
    PG_URL_TEST: ecto://root@127.0.0.1/transport_test

defaults: &defaults
  parameters:
    base_image:
      default: ghcr.io/etalab/transport-ops:elixir-1.13.3-erlang-24.2.1-ubuntu-focal-20211006-transport-tools-1.0.3
      type: string
    # useful to invalidate the build cache manually by bumping the version
    build_cache_key:
      default: build-v2
      type: string
    plt_cache_key:
      default: plt-v4
      type: string
    js_cache_key:
      default: js-v2
      type: string
  working_directory: ~/transport
  docker:
    - *default_docker

defaults_with_postgres: &defaults_with_postgres
  <<: *defaults
  docker:
    - *default_docker
    # https://hub.docker.com/r/postgis/postgis
    # See https://github.com/etalab/transport_deploy/issues/50
    - image: postgis/postgis:14-3.1-alpine
      environment:
        POSTGRES_USER: root
        POSTGRES_DB: transport_test
        POSTGRES_PASSWORD: $POSTGRES_PASSWORD
jobs:
  build:
    <<: *defaults_with_postgres

    steps:
      - checkout

      - run:
          name: Move transport-tools folder
          command: mv /transport-tools ./transport-tools

      - restore_cache:
          # Please read: https://circleci.com/docs/2.0/caching/#restoring-cache
          keys:
            - elixir-<< parameters.base_image >>-<< parameters.build_cache_key >>-{{ .Branch }}-{{ checksum "mix.lock" }}
            - elixir-<< parameters.base_image >>-<< parameters.build_cache_key >>-{{ .Branch }}
            - elixir-<< parameters.base_image >>-<< parameters.build_cache_key >>
      - run:
          name: Install hex
          command: mix local.hex --force

      - run:
          name: Install rebar
          command: mix local.rebar --force

      - run:
          name: Install mix dependencies
          command: mix deps.get

      - run:
          name: Compile code
          command: mix compile

      # Here we attempt to create 3 different caches to optimize the build process

      # Most specific
      - save_cache:
          key: elixir-<< parameters.base_image >>-<< parameters.build_cache_key >>-{{ .Branch }}-{{ checksum "mix.lock" }}
          paths:
            - ~/transport/_build
            - ~/transport/deps
            - ~/.mix

      # Intermediate
      - save_cache:
          key: elixir-<< parameters.base_image >>-<< parameters.build_cache_key >>-{{ .Branch }}
          paths:
            - ~/transport/_build
            - ~/transport/deps
            - ~/.mix

      # Least specific
      - save_cache:
          key: elixir-<< parameters.base_image >>-<< parameters.build_cache_key >>
          paths:
            - ~/transport/_build
            - ~/transport/deps
            - ~/.mix

      - restore_cache:
          keys:
            - js-<< parameters.js_cache_key >>-{{ checksum "apps/transport/client/yarn.lock" }}
            - js-<< parameters.js_cache_key >>
          
      - run:
          name: Install yarn dependencies
          command: cd ~/transport/apps/transport/client && yarn install

      # NOTE: this cannot be cached effectively at time of writing
      - run:
          name: Compile assets
          command: cd ~/transport/apps/transport/client && npm run build

      - save_cache:
          key: js-<< parameters.js_cache_key >>-{{ checksum "apps/transport/client/yarn.lock" }}
          paths: 
            - ~/transport/apps/transport/client/node_modules

      # NOTE: I think this should be moved to the dialyzer parallel section,
      # but then we need to think about how the persistence/caching will be
      # handled, and think about concurrent access (?) with various jobs to the cache.

      - restore_cache:
          keys:
            - elixir-<< parameters.base_image >>-<< parameters.plt_cache_key >>-{{ .Branch }}-{{ checksum "mix.lock" }}
            - elixir-<< parameters.base_image >>-<< parameters.plt_cache_key >>-{{ .Branch }}
            - elixir-<< parameters.base_image >>-<< parameters.plt_cache_key >>

      - run:
          name: Build PLT
          command: mix dialyzer --plt
          # PLT construction can stay up quite a bit without generating any output
          # We add a bit of tolerance here
          no_output_timeout: 20m

      - save_cache:
          key: elixir-<< parameters.base_image >>-<< parameters.plt_cache_key >>-{{ .Branch }}-{{ checksum "mix.lock" }}
          paths:
            - ~/transport/dialyzer-plt

      - save_cache:
          key: elixir-<< parameters.base_image >>-<< parameters.plt_cache_key >>-{{ .Branch }}
          paths:
            - ~/transport/dialyzer-plt

      - save_cache:
          key: elixir-<< parameters.base_image >>-<< parameters.plt_cache_key >>
          paths:
            - ~/transport/dialyzer-plt

      - run:
          name: Run gettext check
          command: mix gettext.extract --check-up-to-date
      
      - run:
          name: Run credo
          command: mix credo --strict
      
      - run:
          name: Run javascript linter
          command: mix npm "run linter:ecma"

      - run:
          name: Run stylesheets linter
          command: mix npm "run linter:sass"

      - run:
          name: Run formatter
          command: mix format --check-formatted --dry-run

      - run:
          name: Run dialyzer (static analysis)
          command: mix dialyzer

      - run:
          name: Run tests
          command: |
            mix test --warnings-as-errors

workflows:
  version: 2
  transport:
    jobs:
      - build:
        branches:
          ignore:
            - blog
